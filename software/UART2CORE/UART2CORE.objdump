
UART2CORE.elf:     file format elf32-littlenios2
UART2CORE.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00001020

Program Header:
    LOAD off    0x00001000 vaddr 0x00001000 paddr 0x00001000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00001020 paddr 0x00001020 align 2**12
         filesz 0x00000514 memsz 0x00000514 flags r-x
    LOAD off    0x00001534 vaddr 0x00001534 paddr 0x000015a4 align 2**12
         filesz 0x00000070 memsz 0x00000070 flags rw-
    LOAD off    0x00001614 vaddr 0x00001614 paddr 0x00001614 align 2**12
         filesz 0x00000000 memsz 0x0000000c flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00001000  00001000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         00000404  00001020  00001020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000110  00001424  00001424  00001424  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rwdata       00000070  00001534  000015a4  00001534  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  4 .bss          0000000c  00001614  00001614  00001614  2**2
                  ALLOC, SMALL_DATA
  5 .comment      00000023  00000000  00000000  000015a4  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000188  00000000  00000000  000015c8  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 0000024f  00000000  00000000  00001750  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0000125c  00000000  00000000  0000199f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00000735  00000000  00000000  00002bfb  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000182c  00000000  00000000  00003330  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000214  00000000  00000000  00004b5c  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000006aa  00000000  00000000  00004d70  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000030c  00000000  00000000  0000541a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_alt_sim_info 00000010  00000000  00000000  00005728  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000020  00000000  00000000  00005738  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .thread_model 00000003  00000000  00000000  000065da  2**0
                  CONTENTS, READONLY
 17 .cpu          00000005  00000000  00000000  000065dd  2**0
                  CONTENTS, READONLY
 18 .simulation_enabled 00000001  00000000  00000000  000065e2  2**0
                  CONTENTS, READONLY
 19 .stderr_dev   0000000b  00000000  00000000  000065e3  2**0
                  CONTENTS, READONLY
 20 .stdin_dev    0000000b  00000000  00000000  000065ee  2**0
                  CONTENTS, READONLY
 21 .stdout_dev   0000000b  00000000  00000000  000065f9  2**0
                  CONTENTS, READONLY
 22 .sopc_system_name 0000000a  00000000  00000000  00006604  2**0
                  CONTENTS, READONLY
 23 .quartus_project_dir 0000001e  00000000  00000000  0000660e  2**0
                  CONTENTS, READONLY
 24 .jdi          00004422  00000000  00000000  0000662c  2**0
                  CONTENTS, READONLY
 25 .sopcinfo     00030236  00000000  00000000  0000aa4e  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00001000 l    d  .entry	00000000 .entry
00001020 l    d  .text	00000000 .text
00001424 l    d  .rodata	00000000 .rodata
00001534 l    d  .rwdata	00000000 .rwdata
00001614 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00001058 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 hello_world_small.c
00001428 l     O .rodata	000000ff symbols.1349
00000000 l    df *ABS*	00000000 lib2-divmod.c
00001140 l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 alt_getchar.c
00000000 l    df *ABS*	00000000 alt_load.c
000012d0 l     F .text	00000020 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
00001410 l     F .text	00000008 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_irq.c
0000135c g     F .text	0000002c alt_main
000015a4 g       *ABS*	00000000 __flash_rwdata_start
00001000 g     F .entry	0000000c __reset
00001020 g       *ABS*	00000000 __flash_exceptions_start
00001618 g     O .bss	00000004 alt_argv
0000958c g       *ABS*	00000000 _gp
0000155c g     O .rwdata	00000030 alt_fd_list
0000141c g     F .text	00000008 altera_nios2_irq_init
000013ac g     F .text	00000060 altera_avalon_jtag_uart_read
00001000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
0000127c g     F .text	00000008 __udivsi3
0000105c g     F .text	00000068 itoa
000015a0 g     O .rwdata	00000004 alt_max_fd
00001620 g       *ABS*	00000000 __bss_end
0000128c g     F .text	00000044 alt_getchar
00001534 g     O .rwdata	00000028 alt_dev_null
0000140c g     F .text	00000004 alt_dcache_flush_all
000015a4 g       *ABS*	00000000 __ram_rwdata_end
00001598 g     O .rwdata	00000008 alt_dev_list
00001534 g       *ABS*	00000000 __ram_rodata_end
0000158c g     O .rwdata	00000004 jtag_uart_0
00001284 g     F .text	00000008 __umodsi3
00001620 g       *ABS*	00000000 end
00002000 g       *ABS*	00000000 __alt_stack_pointer
00001020 g     F .text	0000003c _start
00001388 g     F .text	00000004 alt_sys_init
00001534 g       *ABS*	00000000 __ram_rwdata_start
00001424 g       *ABS*	00000000 __ram_rodata_start
00001620 g       *ABS*	00000000 __alt_stack_base
00001614 g       *ABS*	00000000 __bss_start
000010c4 g     F .text	0000007c main
0000161c g     O .bss	00000004 alt_envp
000011bc g     F .text	00000060 __divsi3
00001424 g       *ABS*	00000000 __flash_rodata_start
0000138c g     F .text	00000020 alt_irq_init
00001614 g     O .bss	00000004 alt_argc
00001590 g     O .rwdata	00000008 alt_fs_list
00001020 g       *ABS*	00000000 __ram_exceptions_start
000015a4 g       *ABS*	00000000 _edata
00001620 g       *ABS*	00000000 _end
00001020 g       *ABS*	00000000 __ram_exceptions_end
0000100c g       .entry	00000000 exit
0000121c g     F .text	00000060 __modsi3
00002000 g       *ABS*	00000000 __alt_data_end
0000100c g       .entry	00000000 _exit
00001418 g     F .text	00000004 alt_icache_flush_all
000012f0 g     F .text	0000006c alt_load



Disassembly of section .entry:

00001000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
    1000:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
    1004:	08440814 	ori	at,at,4128
    jmp r1
    1008:	0800683a 	jmp	at

0000100c <_exit>:
	...

Disassembly of section .text:

00001020 <_start>:
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
    1020:	06c00034 	movhi	sp,0
    ori sp, sp, %lo(__alt_stack_pointer)
    1024:	dec80014 	ori	sp,sp,8192

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
    1028:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
    102c:	d6a56314 	ori	gp,gp,38284
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
    1030:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
    1034:	10858514 	ori	r2,r2,5652

    movhi r3, %hi(__bss_end)
    1038:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
    103c:	18c58814 	ori	r3,r3,5664

    beq r2, r3, 1f
    1040:	10c00326 	beq	r2,r3,1050 <_start+0x30>

0:
    stw zero, (r2)
    1044:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
    1048:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
    104c:	10fffd36 	bltu	r2,r3,1044 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
    1050:	00012f00 	call	12f0 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
    1054:	000135c0 	call	135c <alt_main>

00001058 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
    1058:	003fff06 	br	1058 <alt_after_alt_main>

0000105c <itoa>:

#define rs_out (volatile char *) 0x0003030
#define rs_in (volatile char *) 0x0003020
#define ack (volatile char *) 0x0003010

char* itoa(unsigned char byte) {
    105c:	defffd04 	addi	sp,sp,-12
    1060:	dc400115 	stw	r17,4(sp)
    1064:	dfc00215 	stw	ra,8(sp)
    1068:	dc000015 	stw	r16,0(sp)
    106c:	04400034 	movhi	r17,0
    1070:	8c450984 	addi	r17,r17,5158
	int i;
	char *result = "000";
	for(i = 0; i < 3; i++, byte /= 10) {
		result[2 - i] = (byte % 10 ) + '0';
    1074:	24003fcc 	andi	r16,r4,255
    1078:	8009883a 	mov	r4,r16
    107c:	01400284 	movi	r5,10
    1080:	00012840 	call	1284 <__umodsi3>
    1084:	10800c04 	addi	r2,r2,48
#define ack (volatile char *) 0x0003010

char* itoa(unsigned char byte) {
	int i;
	char *result = "000";
	for(i = 0; i < 3; i++, byte /= 10) {
    1088:	8009883a 	mov	r4,r16
    108c:	01400284 	movi	r5,10
		result[2 - i] = (byte % 10 ) + '0';
    1090:	88800005 	stb	r2,0(r17)
#define ack (volatile char *) 0x0003010

char* itoa(unsigned char byte) {
	int i;
	char *result = "000";
	for(i = 0; i < 3; i++, byte /= 10) {
    1094:	000127c0 	call	127c <__udivsi3>
    1098:	1009883a 	mov	r4,r2
    109c:	8c7fffc4 	addi	r17,r17,-1
    10a0:	00800034 	movhi	r2,0
    10a4:	108508c4 	addi	r2,r2,5155
    10a8:	88bff21e 	bne	r17,r2,1074 <itoa+0x18>
		result[2 - i] = (byte % 10 ) + '0';
	}
	return result;
}
    10ac:	88800044 	addi	r2,r17,1
    10b0:	dfc00217 	ldw	ra,8(sp)
    10b4:	dc400117 	ldw	r17,4(sp)
    10b8:	dc000017 	ldw	r16,0(sp)
    10bc:	dec00304 	addi	sp,sp,12
    10c0:	f800283a 	ret

000010c4 <main>:

int main() {
    10c4:	defffe04 	addi	sp,sp,-8
    10c8:	dc000015 	stw	r16,0(sp)
    10cc:	dfc00115 	stw	ra,4(sp)
    10d0:	04000034 	movhi	r16,0
    10d4:	84050a04 	addi	r16,r16,5160
			83, 116, 33, 147, 150, 150, 205, 167, 14, 29,
			181, 200, 102, 132, 175, 34, 37, 100, 184, 156,
			198, 6, 159, 23, 46};

	for (i = 0; i < 255; i++) {
		*rs_in = symbols[i];
    10d8:	80c00003 	ldbu	r3,0(r16)
    10dc:	008c0804 	movi	r2,12320
		*ack = 1; *ack = 0;
    10e0:	010c0404 	movi	r4,12304
			83, 116, 33, 147, 150, 150, 205, 167, 14, 29,
			181, 200, 102, 132, 175, 34, 37, 100, 184, 156,
			198, 6, 159, 23, 46};

	for (i = 0; i < 255; i++) {
		*rs_in = symbols[i];
    10e4:	10c00005 	stb	r3,0(r2)
		*ack = 1; *ack = 0;
    10e8:	00800044 	movi	r2,1
    10ec:	20800005 	stb	r2,0(r4)
    10f0:	20000005 	stb	zero,0(r4)
		alt_getchar();
    10f4:	000128c0 	call	128c <alt_getchar>
    10f8:	84000044 	addi	r16,r16,1
			221, 222, 65, 132, 17, 131, 177, 31, 219,
			83, 116, 33, 147, 150, 150, 205, 167, 14, 29,
			181, 200, 102, 132, 175, 34, 37, 100, 184, 156,
			198, 6, 159, 23, 46};

	for (i = 0; i < 255; i++) {
    10fc:	00800034 	movhi	r2,0
    1100:	108549c4 	addi	r2,r2,5415
    1104:	80bff41e 	bne	r16,r2,10d8 <main+0x14>
    1108:	0021883a 	mov	r16,zero
		*ack = 1; *ack = 0;
		alt_getchar();

	}
	for (i = 0; i < 32; i++) {
		alt_getchar();
    110c:	000128c0 	call	128c <alt_getchar>
		*ack = 1; *ack = 0;
    1110:	008c0404 	movi	r2,12304
    1114:	00c00044 	movi	r3,1
    1118:	10c00005 	stb	r3,0(r2)
    111c:	10000005 	stb	zero,0(r2)
		*rs_in = symbols[i];
		*ack = 1; *ack = 0;
		alt_getchar();

	}
	for (i = 0; i < 32; i++) {
    1120:	84000044 	addi	r16,r16,1
    1124:	00800804 	movi	r2,32
    1128:	80bff81e 	bne	r16,r2,110c <main+0x48>
		alt_getchar();
		*ack = 1; *ack = 0;
	}
	return 0;
}
    112c:	0005883a 	mov	r2,zero
    1130:	dfc00117 	ldw	ra,4(sp)
    1134:	dc000017 	ldw	r16,0(sp)
    1138:	dec00204 	addi	sp,sp,8
    113c:	f800283a 	ret

00001140 <udivmodsi4>:
    1140:	29001b2e 	bgeu	r5,r4,11b0 <udivmodsi4+0x70>
    1144:	28001a16 	blt	r5,zero,11b0 <udivmodsi4+0x70>
    1148:	00800044 	movi	r2,1
    114c:	0007883a 	mov	r3,zero
    1150:	01c007c4 	movi	r7,31
    1154:	00000306 	br	1164 <udivmodsi4+0x24>
    1158:	19c01326 	beq	r3,r7,11a8 <udivmodsi4+0x68>
    115c:	18c00044 	addi	r3,r3,1
    1160:	28000416 	blt	r5,zero,1174 <udivmodsi4+0x34>
    1164:	294b883a 	add	r5,r5,r5
    1168:	1085883a 	add	r2,r2,r2
    116c:	293ffa36 	bltu	r5,r4,1158 <udivmodsi4+0x18>
    1170:	10000d26 	beq	r2,zero,11a8 <udivmodsi4+0x68>
    1174:	0007883a 	mov	r3,zero
    1178:	21400236 	bltu	r4,r5,1184 <udivmodsi4+0x44>
    117c:	2149c83a 	sub	r4,r4,r5
    1180:	1886b03a 	or	r3,r3,r2
    1184:	1004d07a 	srli	r2,r2,1
    1188:	280ad07a 	srli	r5,r5,1
    118c:	103ffa1e 	bne	r2,zero,1178 <udivmodsi4+0x38>
    1190:	30000226 	beq	r6,zero,119c <udivmodsi4+0x5c>
    1194:	2005883a 	mov	r2,r4
    1198:	f800283a 	ret
    119c:	1809883a 	mov	r4,r3
    11a0:	2005883a 	mov	r2,r4
    11a4:	f800283a 	ret
    11a8:	0007883a 	mov	r3,zero
    11ac:	003ff806 	br	1190 <udivmodsi4+0x50>
    11b0:	00800044 	movi	r2,1
    11b4:	0007883a 	mov	r3,zero
    11b8:	003fef06 	br	1178 <udivmodsi4+0x38>

000011bc <__divsi3>:
    11bc:	defffe04 	addi	sp,sp,-8
    11c0:	dc000015 	stw	r16,0(sp)
    11c4:	dfc00115 	stw	ra,4(sp)
    11c8:	0021883a 	mov	r16,zero
    11cc:	20000c16 	blt	r4,zero,1200 <__divsi3+0x44>
    11d0:	000d883a 	mov	r6,zero
    11d4:	28000e16 	blt	r5,zero,1210 <__divsi3+0x54>
    11d8:	00011400 	call	1140 <udivmodsi4>
    11dc:	1007883a 	mov	r3,r2
    11e0:	8005003a 	cmpeq	r2,r16,zero
    11e4:	1000011e 	bne	r2,zero,11ec <__divsi3+0x30>
    11e8:	00c7c83a 	sub	r3,zero,r3
    11ec:	1805883a 	mov	r2,r3
    11f0:	dfc00117 	ldw	ra,4(sp)
    11f4:	dc000017 	ldw	r16,0(sp)
    11f8:	dec00204 	addi	sp,sp,8
    11fc:	f800283a 	ret
    1200:	0109c83a 	sub	r4,zero,r4
    1204:	04000044 	movi	r16,1
    1208:	000d883a 	mov	r6,zero
    120c:	283ff20e 	bge	r5,zero,11d8 <__divsi3+0x1c>
    1210:	014bc83a 	sub	r5,zero,r5
    1214:	8021003a 	cmpeq	r16,r16,zero
    1218:	003fef06 	br	11d8 <__divsi3+0x1c>

0000121c <__modsi3>:
    121c:	deffff04 	addi	sp,sp,-4
    1220:	dfc00015 	stw	ra,0(sp)
    1224:	01800044 	movi	r6,1
    1228:	2807883a 	mov	r3,r5
    122c:	20000416 	blt	r4,zero,1240 <__modsi3+0x24>
    1230:	28000c16 	blt	r5,zero,1264 <__modsi3+0x48>
    1234:	dfc00017 	ldw	ra,0(sp)
    1238:	dec00104 	addi	sp,sp,4
    123c:	00011401 	jmpi	1140 <udivmodsi4>
    1240:	0109c83a 	sub	r4,zero,r4
    1244:	28000b16 	blt	r5,zero,1274 <__modsi3+0x58>
    1248:	180b883a 	mov	r5,r3
    124c:	01800044 	movi	r6,1
    1250:	00011400 	call	1140 <udivmodsi4>
    1254:	0085c83a 	sub	r2,zero,r2
    1258:	dfc00017 	ldw	ra,0(sp)
    125c:	dec00104 	addi	sp,sp,4
    1260:	f800283a 	ret
    1264:	014bc83a 	sub	r5,zero,r5
    1268:	dfc00017 	ldw	ra,0(sp)
    126c:	dec00104 	addi	sp,sp,4
    1270:	00011401 	jmpi	1140 <udivmodsi4>
    1274:	0147c83a 	sub	r3,zero,r5
    1278:	003ff306 	br	1248 <__modsi3+0x2c>

0000127c <__udivsi3>:
    127c:	000d883a 	mov	r6,zero
    1280:	00011401 	jmpi	1140 <udivmodsi4>

00001284 <__umodsi3>:
    1284:	01800044 	movi	r6,1
    1288:	00011401 	jmpi	1140 <udivmodsi4>

0000128c <alt_getchar>:
{
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
    128c:	00800034 	movhi	r2,0
    1290:	10855704 	addi	r2,r2,5468
    1294:	11c00217 	ldw	r7,8(r2)
 * Uses the ALT_DRIVER_READ() macro to call directly to driver if available.
 * Otherwise, uses newlib provided getchar() routine.
 */
int 
alt_getchar(void)
{
    1298:	defffe04 	addi	sp,sp,-8
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
    129c:	01000034 	movhi	r4,0
    12a0:	21056304 	addi	r4,r4,5516
    12a4:	d80b883a 	mov	r5,sp
    12a8:	01800044 	movi	r6,1
 * Uses the ALT_DRIVER_READ() macro to call directly to driver if available.
 * Otherwise, uses newlib provided getchar() routine.
 */
int 
alt_getchar(void)
{
    12ac:	dfc00115 	stw	ra,4(sp)
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
    12b0:	00013ac0 	call	13ac <altera_avalon_jtag_uart_read>
    12b4:	00ffffc4 	movi	r3,-1
    12b8:	0080010e 	bge	zero,r2,12c0 <alt_getchar+0x34>
        return -1;
    }
    return c;
    12bc:	d8c00007 	ldb	r3,0(sp)
#else
    return getchar();
#endif
}
    12c0:	1805883a 	mov	r2,r3
    12c4:	dfc00117 	ldw	ra,4(sp)
    12c8:	dec00204 	addi	sp,sp,8
    12cc:	f800283a 	ret

000012d0 <alt_load_section>:

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    12d0:	2900051e 	bne	r5,r4,12e8 <alt_load_section+0x18>
    12d4:	f800283a 	ret
  {
    while( to != end )
    {
      *to++ = *from++;
    12d8:	20800017 	ldw	r2,0(r4)
    12dc:	21000104 	addi	r4,r4,4
    12e0:	28800015 	stw	r2,0(r5)
    12e4:	29400104 	addi	r5,r5,4
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
    12e8:	29bffb1e 	bne	r5,r6,12d8 <alt_load_section+0x8>
    12ec:	f800283a 	ret

000012f0 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
    12f0:	deffff04 	addi	sp,sp,-4
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
    12f4:	01000034 	movhi	r4,0
    12f8:	21056904 	addi	r4,r4,5540
    12fc:	01400034 	movhi	r5,0
    1300:	29454d04 	addi	r5,r5,5428
    1304:	01800034 	movhi	r6,0
    1308:	31856904 	addi	r6,r6,5540
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
    130c:	dfc00015 	stw	ra,0(sp)
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
    1310:	00012d00 	call	12d0 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
    1314:	01000034 	movhi	r4,0
    1318:	21040804 	addi	r4,r4,4128
    131c:	01400034 	movhi	r5,0
    1320:	29440804 	addi	r5,r5,4128
    1324:	01800034 	movhi	r6,0
    1328:	31840804 	addi	r6,r6,4128
    132c:	00012d00 	call	12d0 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
    1330:	01000034 	movhi	r4,0
    1334:	21050904 	addi	r4,r4,5156
    1338:	01400034 	movhi	r5,0
    133c:	29450904 	addi	r5,r5,5156
    1340:	01800034 	movhi	r6,0
    1344:	31854d04 	addi	r6,r6,5428
    1348:	00012d00 	call	12d0 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
    134c:	000140c0 	call	140c <alt_dcache_flush_all>
  alt_icache_flush_all();
}
    1350:	dfc00017 	ldw	ra,0(sp)
    1354:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
    1358:	00014181 	jmpi	1418 <alt_icache_flush_all>

0000135c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    135c:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    1360:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    1364:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    1368:	000138c0 	call	138c <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
    136c:	00013880 	call	1388 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    1370:	d1202217 	ldw	r4,-32632(gp)
    1374:	d1602317 	ldw	r5,-32628(gp)
    1378:	d1a02417 	ldw	r6,-32624(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
    137c:	dfc00017 	ldw	ra,0(sp)
    1380:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    1384:	00010c41 	jmpi	10c4 <main>

00001388 <alt_sys_init>:
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
}
    1388:	f800283a 	ret

0000138c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
    138c:	deffff04 	addi	sp,sp,-4
    1390:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_IRQ_INIT ( CPU_0, cpu_0);
    1394:	000141c0 	call	141c <altera_nios2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
    1398:	00800044 	movi	r2,1
    139c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
    13a0:	dfc00017 	ldw	ra,0(sp)
    13a4:	dec00104 	addi	sp,sp,4
    13a8:	f800283a 	ret

000013ac <altera_avalon_jtag_uart_read>:

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char* buffer, int space, int flags)
{
  unsigned int base = sp->base;
    13ac:	21000017 	ldw	r4,0(r4)
    13b0:	3890000c 	andi	r2,r7,16384

  char * ptr = buffer;
  char * end = buffer + space;
    13b4:	2993883a 	add	r9,r5,r6
    13b8:	1010c03a 	cmpne	r8,r2,zero
    13bc:	2807883a 	mov	r3,r5
    13c0:	00000806 	br	13e4 <altera_avalon_jtag_uart_read+0x38>

  while (ptr < end)
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
    13c4:	21800037 	ldwio	r6,0(r4)

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
    13c8:	30a0000c 	andi	r2,r6,32768
    13cc:	10000326 	beq	r2,zero,13dc <altera_avalon_jtag_uart_read+0x30>
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
    13d0:	19800005 	stb	r6,0(r3)
    13d4:	18c00044 	addi	r3,r3,1
    13d8:	00000206 	br	13e4 <altera_avalon_jtag_uart_read+0x38>
    else if (ptr != buffer)
    13dc:	1940031e 	bne	r3,r5,13ec <altera_avalon_jtag_uart_read+0x40>
      break;
    else if(flags & O_NONBLOCK)
    13e0:	4000081e 	bne	r8,zero,1404 <altera_avalon_jtag_uart_read+0x58>
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;

  while (ptr < end)
    13e4:	1a7ff736 	bltu	r3,r9,13c4 <altera_avalon_jtag_uart_read+0x18>
    else if(flags & O_NONBLOCK)
      break;   
    
  }

  if (ptr != buffer)
    13e8:	19400226 	beq	r3,r5,13f4 <altera_avalon_jtag_uart_read+0x48>
    return ptr - buffer;
    13ec:	1945c83a 	sub	r2,r3,r5
    13f0:	f800283a 	ret
  else if (flags & O_NONBLOCK)
    13f4:	3890000c 	andi	r2,r7,16384
    13f8:	1000021e 	bne	r2,zero,1404 <altera_avalon_jtag_uart_read+0x58>
    13fc:	00bffec4 	movi	r2,-5
    1400:	f800283a 	ret
    1404:	00bffd44 	movi	r2,-11
    return -EWOULDBLOCK;
  else
    return -EIO;
}
    1408:	f800283a 	ret

0000140c <alt_dcache_flush_all>:
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
    140c:	f800283a 	ret

00001410 <alt_dev_null_write>:
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  return len;
}
    1410:	3005883a 	mov	r2,r6
    1414:	f800283a 	ret

00001418 <alt_icache_flush_all>:
void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
    1418:	f800283a 	ret

0000141c <altera_nios2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
    141c:	000170fa 	wrctl	ienable,zero
}
    1420:	f800283a 	ret
